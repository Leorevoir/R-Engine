<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R-Engine ECS Documentation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>R-Engine</h1>
            <p>ECS Documentation</p>
        </div>
        <ul class="nav-menu">
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#architecture">Architecture</a></li>
            <li><a href="#core-concepts">Concepts ClÃ©s</a>
                <ul>
                    <li><a href="#entities">Entities</a></li>
                    <li><a href="#components">Components</a></li>
                    <li><a href="#systems">Systems</a></li>
                    <li><a href="#resources">Resources</a></li>
                    <li><a href="#queries">Queries</a></li>
                    <li><a href="#commands">Commands</a></li>
                </ul>
            </li>
            <li><a href="#advanced">FonctionnalitÃ©s AvancÃ©es</a>
                <ul>
                    <li><a href="#events">Events</a></li>
                    <li><a href="#hierarchies">Hierarchies</a></li>
                    <li><a href="#run-conditions">Run Conditions</a></li>
                    <li><a href="#schedules">Schedules</a></li>
                </ul>
            </li>
            <li><a href="#storage">SystÃ¨me de Stockage</a></li>
            <li><a href="#examples">Exemples</a></li>
            <li><a href="#api-reference">RÃ©fÃ©rence API</a></li>
        </ul>
    </nav>

    <main class="content">
        <!-- Introduction -->
        <section id="introduction" class="section">
            <h1>Introduction Ã  l'ECS R-Engine</h1>
            <p class="lead">
                R-Engine utilise une architecture <strong>Entity Component System (ECS)</strong> inspirÃ©e de Bevy, 
                conÃ§ue pour offrir performance, flexibilitÃ© et simplicitÃ© d'utilisation.
            </p>
            
            <div class="info-box">
                <h3>Qu'est-ce qu'un ECS ?</h3>
                <p>
                    Un ECS est un patron de conception architectural qui sÃ©pare les donnÃ©es (Components) 
                    de la logique (Systems), en les reliant via des entitÃ©s (Entities). Cette approche 
                    favorise la composition plutÃ´t que l'hÃ©ritage et permet un code plus modulaire et performant.
                </p>
            </div>

            <h2>CaractÃ©ristiques Principales</h2>
            <ul class="feature-list">
                <li><strong>ArchÃ©type-based Storage</strong> : Stockage optimisÃ© par archÃ©type pour des performances maximales</li>
                <li><strong>Type Safety</strong> : SystÃ¨me de types compile-time pour Ã©viter les erreurs</li>
                <li><strong>Dependency Injection</strong> : RÃ©solution automatique des dÃ©pendances systÃ¨me</li>
                <li><strong>Command Buffer</strong> : Modifications diffÃ©rÃ©es pour Ã©viter l'invalidation des itÃ©rateurs</li>
                <li><strong>Events System</strong> : Communication asynchrone entre systÃ¨mes</li>
                <li><strong>Hierarchy Support</strong> : Relations parent-enfant natives</li>
            </ul>
        </section>

        <!-- Architecture -->
        <section id="architecture" class="section">
            <h1>Architecture du SystÃ¨me</h1>
            
            <div class="architecture-diagram">
                <pre class="diagram">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Application                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              Scene (ECS World)                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚         Archetype Storage                 â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â”‚ Archetype  â”‚ Archetype  â”‚ Archetype â”‚ â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â”‚   [A,B]    â”‚   [A,C]    â”‚   [B,C]   â”‚ â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚  â”‚
â”‚  â”‚  â”‚         Resources (Global Data)          â”‚ â”‚  â”‚
â”‚  â”‚  â”‚         Entity Locations Map             â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚                                                â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚          System Scheduler                 â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ STARTUP Systems                        â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ UPDATE Systems                         â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  â€¢ RENDER Systems                         â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚                                                â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚          Command Buffer                   â”‚ â”‚  â”‚
â”‚  â”‚  â”‚  Queue de modifications diffÃ©rÃ©es         â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </pre>
            </div>

            <h2>Flux d'ExÃ©cution</h2>
            <ol class="execution-flow">
                <li><strong>Initialisation</strong> : CrÃ©ation de la Scene et exÃ©cution des systÃ¨mes STARTUP</li>
                <li><strong>Boucle Principale</strong> :
                    <ol>
                        <li>ExÃ©cution des systÃ¨mes UPDATE (logique du jeu)</li>
                        <li>Application du Command Buffer (modifications structurelles)</li>
                        <li>ExÃ©cution des systÃ¨mes RENDER (affichage)</li>
                        <li>Update des Events (double buffering)</li>
                    </ol>
                </li>
            </ol>
        </section>

        <!-- Core Concepts -->
        <section id="core-concepts" class="section">
            <h1>Concepts ClÃ©s</h1>

            <!-- Entities -->
            <div id="entities" class="subsection">
                <h2>Entities (EntitÃ©s)</h2>
                <p>
                    Une entitÃ© est simplement un identifiant unique (<code>u32</code>) qui regroupe des composants.
                    Elle n'a pas de donnÃ©es ou de comportement propre.
                </p>
                
                <div class="code-block">
                    <div class="code-header">Entity.hpp</div>
                    <pre><code class="cpp">namespace r::ecs {
    using Entity = u32;
    static constexpr Entity NULL_ENTITY = static_cast&lt;Entity&gt;(-1);
}</code></pre>
                </div>

                <h3>CrÃ©ation d'EntitÃ©s</h3>
                <div class="code-block">
                    <div class="code-header">Exemple</div>
                    <pre><code class="cpp">void spawn_system(Commands &commands) {
    // CrÃ©er une entitÃ© vide
    Entity entity = commands.spawn().id();
    
    // CrÃ©er une entitÃ© avec des composants
    commands.spawn(
        Position{0.0f, 0.0f},
        Velocity{1.0f, 0.0f},
        Health{100}
    );
}</code></pre>
                </div>
            </div>

            <!-- Components -->
            <div id="components" class="subsection">
                <h2>Components (Composants)</h2>
                <p>
                    Les composants sont des structures de donnÃ©es pures qui dÃ©finissent les propriÃ©tÃ©s d'une entitÃ©.
                    Ils ne contiennent pas de logique, seulement des donnÃ©es.
                </p>

                <div class="best-practices">
                    <h3>Bonnes Pratiques</h3>
                    <ul>
                        <li>Garder les composants simples et focused</li>
                        <li>Utiliser des structs POD (Plain Old Data) autant que possible</li>
                        <li>PrÃ©fÃ©rer plusieurs petits composants Ã  un gros composant monolithique</li>
                        <li>Utiliser des marker components (sans donnÃ©es) pour taguer des entitÃ©s</li>
                    </ul>
                </div>

                <div class="code-block">
                    <div class="code-header">Exemples de Composants</div>
                    <pre><code class="cpp">// Composant de donnÃ©es
struct Position {
    Vec2f value;
};

// Composant de donnÃ©es
struct Velocity {
    Vec2f value;
};

// Composant graphique
struct Circle {
    float radius;
    Color color;
};

// Marker component (sans donnÃ©es)
struct Player {};

// Composant complexe
struct Health {
    float current;
    float max;
    
    bool is_alive() const { return current > 0.0f; }
    float percentage() const { return current / max; }
};</code></pre>
                </div>
            </div>

            <!-- Systems -->
            <div id="systems" class="subsection">
                <h2>Systems (SystÃ¨mes)</h2>
                <p>
                    Les systÃ¨mes sont des fonctions qui implÃ©mentent la logique de votre application.
                    Ils opÃ¨rent sur des entitÃ©s via des queries et peuvent accÃ©der aux ressources globales.
                </p>

                <h3>Anatomie d'un SystÃ¨me</h3>
                <div class="code-block">
                    <div class="code-header">Structure de Base</div>
                    <pre><code class="cpp">// SystÃ¨me simple
void movement_system(
    Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query,
    Res&lt;FrameTime&gt; time
) {
    for (auto [pos, vel] : query) {
        pos.ptr->value += vel.ptr->value * time.ptr->delta_time;
    }
}</code></pre>
                </div>

                <h3>ParamÃ¨tres de SystÃ¨me</h3>
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Utilisation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Query&lt;...&gt;</code></td>
                            <td>ItÃ©rer sur des entitÃ©s avec certains composants</td>
                            <td>Logique sur plusieurs entitÃ©s</td>
                        </tr>
                        <tr>
                            <td><code>Res&lt;T&gt;</code></td>
                            <td>AccÃ¨s lecture seule Ã  une ressource</td>
                            <td>Lire configuration, temps, etc.</td>
                        </tr>
                        <tr>
                            <td><code>ResMut&lt;T&gt;</code></td>
                            <td>AccÃ¨s mutable Ã  une ressource</td>
                            <td>Modifier Ã©tat global</td>
                        </tr>
                        <tr>
                            <td><code>Commands</code></td>
                            <td>Buffer de commandes diffÃ©rÃ©es</td>
                            <td>Spawn, despawn, add/remove components</td>
                        </tr>
                        <tr>
                            <td><code>EventWriter&lt;T&gt;</code></td>
                            <td>Envoyer des Ã©vÃ©nements</td>
                            <td>Communication asynchrone</td>
                        </tr>
                        <tr>
                            <td><code>EventReader&lt;T&gt;</code></td>
                            <td>Lire des Ã©vÃ©nements</td>
                            <td>RÃ©agir aux Ã©vÃ©nements</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <div class="code-header">Exemple Complet</div>
                    <pre><code class="cpp">void complex_system(
    Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;, With&lt;Player&gt;&gt; query,
    Res&lt;FrameTime&gt; time,
    Res&lt;UserInput&gt; input,
    Commands &commands,
    EventWriter&lt;CollisionEvent&gt; collision_events
) {
    for (auto [pos, vel, _] : query) {
        // Logique du systÃ¨me...
        pos.ptr->value += vel.ptr->value * time.ptr->delta_time;
        
        // Envoyer un Ã©vÃ©nement
        collision_events.send(CollisionEvent{/* ... */});
        
        // Spawn une nouvelle entitÃ©
        commands.spawn(Particle{/* ... */});
    }
}</code></pre>
                </div>

                <h3>Enregistrement des SystÃ¨mes</h3>
                <div class="code-block">
                    <div class="code-header">Application.cpp</div>
                    <pre><code class="cpp">Application{}
    // SystÃ¨mes STARTUP (exÃ©cutÃ©s une fois au dÃ©marrage)
    .add_systems&lt;setup_system, spawn_entities&gt;(Schedule::STARTUP)
    
    // SystÃ¨mes UPDATE (exÃ©cutÃ©s chaque frame)
    .add_systems&lt;
        input_system,
        movement_system,
        collision_system
    &gt;(Schedule::UPDATE)
    
    // DÃ©finir l'ordre d'exÃ©cution
    .after&lt;input_system&gt;()
    
    // SystÃ¨mes RENDER
    .add_systems&lt;render_system&gt;(Schedule::RENDER_2D)
    .run();</code></pre>
                </div>
            </div>

            <!-- Resources -->
            <div id="resources" class="subsection">
                <h2>Resources (Ressources)</h2>
                <p>
                    Les ressources sont des donnÃ©es globales, uniques, accessibles par tous les systÃ¨mes.
                    Elles sont parfaites pour stocker la configuration, l'Ã©tat global, ou des services.
                </p>

                <div class="code-block">
                    <div class="code-header">DÃ©finition et Utilisation</div>
                    <pre><code class="cpp">// DÃ©finir une ressource
struct GameConfig {
    float gravity = 9.81f;
    int max_enemies = 100;
};

// InsÃ©rer dans l'application
Application{}
    .insert_resource(GameConfig{})
    .run();

// AccÃ©der en lecture seule
void physics_system(Res&lt;GameConfig&gt; config) {
    float g = config.ptr->gravity;
}

// AccÃ©der en Ã©criture
void difficulty_system(ResMut&lt;GameConfig&gt; config) {
    config.ptr->max_enemies = 150;
}

// Ajouter/retirer dynamiquement
void management_system(Commands &commands) {
    commands.insert_resource(NewResource{});
    commands.remove_resource&lt;OldResource&gt;();
}</code></pre>
                </div>
            </div>

            <!-- Queries -->
            <div id="queries" class="subsection">
                <h2>Queries (RequÃªtes)</h2>
                <p>
                    Les queries permettent d'itÃ©rer sur des entitÃ©s qui correspondent Ã  certains critÃ¨res.
                    Elles supportent plusieurs types de filtres et d'accÃ¨s.
                </p>

                <h3>Types d'AccÃ¨s</h3>
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Wrapper</th>
                            <th>Description</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Mut&lt;T&gt;</code></td>
                            <td>AccÃ¨s mutable au composant T</td>
                            <td><code>Mut&lt;Position&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>Ref&lt;T&gt;</code></td>
                            <td>AccÃ¨s lecture seule au composant T</td>
                            <td><code>Ref&lt;Velocity&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>With&lt;T&gt;</code></td>
                            <td>Filtre: requiert le composant T (sans accÃ¨s)</td>
                            <td><code>With&lt;Player&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>Without&lt;T&gt;</code></td>
                            <td>Filtre: exclut les entitÃ©s avec T</td>
                            <td><code>Without&lt;Dead&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>Optional&lt;T&gt;</code></td>
                            <td>AccÃ¨s optionnel (nullptr si absent)</td>
                            <td><code>Optional&lt;Armor&gt;</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <div class="code-header">Exemples de Queries</div>
                    <pre><code class="cpp">// Query simple: toutes les entitÃ©s avec Position
void simple(Query&lt;Ref&lt;Position&gt;&gt; query) {
    for (auto [pos] : query) {
        // pos.ptr est const Position*
    }
}

// Query avec modification
void movement(Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query) {
    for (auto [pos, vel] : query) {
        pos.ptr->value += vel.ptr->value;
    }
}

// Query avec filtres
void player_only(Query&lt;Mut&lt;Health&gt;, With&lt;Player&gt;&gt; query) {
    for (auto [health, _] : query) {
        // Seulement les entitÃ©s Player
    }
}

// Exclure certaines entitÃ©s
void alive_enemies(
    Query&lt;Ref&lt;Position&gt;, With&lt;Enemy&gt;, Without&lt;Dead&gt;&gt; query
) {
    for (auto [pos, _, __] : query) {
        // Ennemis vivants uniquement
    }
}

// Composants optionnels
void render(Query&lt;Ref&lt;Position&gt;, Optional&lt;Sprite&gt;&gt; query) {
    for (auto [pos, sprite_opt] : query) {
        if (sprite_opt.ptr != nullptr) {
            // EntitÃ© a un sprite
        } else {
            // Pas de sprite
        }
    }
}

// RÃ©cupÃ©rer l'ID de l'entitÃ©
void id_access(Query&lt;Ref&lt;Health&gt;&gt; query) {
    for (auto iter = query.begin(); iter != query.end(); ++iter) {
        Entity e = iter.entity();
        auto [health] = *iter;
    }
}</code></pre>
                </div>

                <div class="warning-box">
                    <h4>âš ï¸ Important</h4>
                    <p>
                        Ne modifiez jamais la structure de l'ECS (spawn, despawn, add/remove components)
                        pendant l'itÃ©ration d'une query. Utilisez plutÃ´t <code>Commands</code> pour
                        diffÃ©rer ces opÃ©rations.
                    </p>
                </div>
            </div>

            <!-- Commands -->
            <div id="commands" class="subsection">
                <h2>Commands (Commandes)</h2>
                <p>
                    Le systÃ¨me de commandes permet de diffÃ©rer les modifications structurelles de l'ECS
                    (crÃ©ation/destruction d'entitÃ©s, ajout/suppression de composants) pour Ã©viter
                    l'invalidation des itÃ©rateurs pendant l'exÃ©cution des systÃ¨mes.
                </p>

                <h3>API des Commandes</h3>
                <div class="code-block">
                    <div class="code-header">OpÃ©rations Disponibles</div>
                    <pre><code class="cpp">void example_system(Commands &commands) {
    // ===== Gestion des EntitÃ©s =====
    
    // Spawn une entitÃ© vide
    Entity e1 = commands.spawn().id();
    
    // Spawn avec composants
    EntityCommands entity = commands.spawn(
        Position{0, 0},
        Velocity{1, 1}
    );
    
    // ChaÃ®nage de commandes
    commands.spawn()
        .insert(Position{10, 10})
        .insert(Velocity{0, 1})
        .insert(Health{100});
    
    // Despawn une entitÃ©
    commands.despawn(entity_id);
    
    // ===== Gestion des Composants =====
    
    // Ajouter un composant
    commands.entity(entity_id).insert(NewComponent{});
    commands.add_component(entity_id, Armor{50});
    
    // Retirer un composant
    commands.entity(entity_id).remove&lt;OldComponent&gt;();
    
    // ===== Gestion des Ressources =====
    
    // InsÃ©rer une ressource
    commands.insert_resource(GameState{});
    
    // Retirer une ressource
    commands.remove_resource&lt;GameState&gt;();
}</code></pre>
                </div>

                <h3>HiÃ©rarchies Parent-Enfant</h3>
                <div class="code-block">
                    <div class="code-header">Relations HiÃ©rarchiques</div>
                    <pre><code class="cpp">void spawn_hierarchy(Commands &commands) {
    // MÃ©thode 1: with_children
    commands.spawn(Transform{})
        .with_children([](ChildBuilder &builder) {
            builder.spawn(ChildTransform{});
            builder.spawn(ChildTransform{});
        });
    
    // MÃ©thode 2: Manuelle
    Entity parent = commands.spawn(Transform{}).id();
    Entity child1 = commands.spawn(ChildTransform{}).id();
    Entity child2 = commands.spawn(ChildTransform{}).id();
    
    commands.add_child(parent, child1);
    commands.add_child(parent, child2);
}</code></pre>
                </div>

                <div class="info-box">
                    <h4>ğŸ’¡ Moment d'Application</h4>
                    <p>
                        Toutes les commandes sont appliquÃ©es automatiquement Ã  la fin du schedule courant,
                        juste avant l'application suivante des systÃ¨mes. Vous n'avez pas besoin d'appeler
                        manuellement <code>apply()</code>.
                    </p>
                </div>
            </div>
        </section>

        <!-- Advanced Features -->
        <section id="advanced" class="section">
            <h1>FonctionnalitÃ©s AvancÃ©es</h1>

            <!-- Events -->
            <div id="events" class="subsection">
                <h2>Events (Ã‰vÃ©nements)</h2>
                <p>
                    Le systÃ¨me d'Ã©vÃ©nements permet une communication asynchrone entre systÃ¨mes.
                    Les Ã©vÃ©nements utilisent un double buffering: les Ã©vÃ©nements envoyÃ©s Ã  la frame N
                    sont lisibles Ã  la frame N+1.
                </p>

                <div class="code-block">
                    <div class="code-header">DÃ©finition et Utilisation</div>
                    <pre><code class="cpp">// 1. DÃ©finir un type d'Ã©vÃ©nement
struct CollisionEvent {
    Entity entity_a;
    Entity entity_b;
    Vec2f point;
};

// 2. Ajouter le plugin Events Ã  l'application
Application{}
    .add_event&lt;CollisionEvent&gt;()
    .run();

// 3. Envoyer des Ã©vÃ©nements
void collision_detection(EventWriter&lt;CollisionEvent&gt; writer) {
    // DÃ©tection de collision...
    writer.send(CollisionEvent{
        .entity_a = entity1,
        .entity_b = entity2,
        .point = {10.0f, 20.0f}
    });
}

// 4. Lire des Ã©vÃ©nements
void collision_response(EventReader&lt;CollisionEvent&gt; reader) {
    // VÃ©rifier s'il y a des Ã©vÃ©nements
    if (!reader.has_events()) {
        return;
    }
    
    // ItÃ©rer sur les Ã©vÃ©nements
    for (const CollisionEvent &event : reader) {
        std::cout << "Collision at: " 
                  << event.point.x << ", " 
                  << event.point.y << std::endl;
    }
}</code></pre>
                </div>

                <div class="warning-box">
                    <h4>âš ï¸ DurÃ©e de Vie</h4>
                    <p>
                        Les Ã©vÃ©nements ne persistent qu'une seule frame. Ils sont automatiquement
                        nettoyÃ©s au dÃ©but de chaque nouveau cycle de frame.
                    </p>
                </div>
            </div>

            <!-- Hierarchies -->
            <div id="hierarchies" class="subsection">
                <h2>Hierarchies (HiÃ©rarchies)</h2>
                <p>
                    R-Engine supporte nativement les relations parent-enfant via les composants
                    <code>Parent</code> et <code>Children</code>.
                </p>

                <div class="code-block">
                    <div class="code-header">Composants de HiÃ©rarchie</div>
                    <pre><code class="cpp">// Composants automatiques
struct Parent {
    Entity entity;  // L'entitÃ© parente
};

struct Children {
    std::vector&lt;Entity&gt; entities;  // Les enfants
};

// CrÃ©ation d'une hiÃ©rarchie
void spawn_player(Commands &commands) {
    commands.spawn(PlayerController{})
        .with_children([](ChildBuilder &builder) {
            // Arme
            builder.spawn(Weapon{});
            
            // ModÃ¨le 3D
            builder.spawn(Model{});
            
            // Particules
            builder.spawn(ParticleEmitter{});
        });
}

// Parcourir une hiÃ©rarchie
void traverse_hierarchy(
    Query&lt;Ref&lt;Children&gt;&gt; parents_query,
    Query&lt;Ref&lt;Transform&gt;&gt; transforms_query
) {
    for (auto [children] : parents_query) {
        for (Entity child : children.ptr->entities) {
            // Traiter chaque enfant
        }
    }
}</code></pre>
                </div>
            </div>

            <!-- Run Conditions -->
            <div id="run-conditions" class="subsection">
                <h2>Run Conditions (Conditions d'ExÃ©cution)</h2>
                <p>
                    Les run conditions permettent d'exÃ©cuter des systÃ¨mes conditionnellement,
                    en fonction de l'Ã©tat de l'application ou de la prÃ©sence d'Ã©vÃ©nements.
                </p>

                <div class="code-block">
                    <div class="code-header">Conditions Disponibles</div>
                    <pre><code class="cpp">// DÃ©finir un Ã©tat
enum class AppState {
    MainMenu,
    Playing,
    Paused
};

Application{}
    .insert_resource(State&lt;AppState&gt;{AppState::MainMenu})
    
    // ExÃ©cuter seulement dans un Ã©tat spÃ©cifique
    .add_systems&lt;game_logic&gt;(Schedule::UPDATE)
        .run_if&lt;in_state&lt;AppState::Playing&gt;&gt;()
    
    // ExÃ©cuter quand l'Ã©tat change
    .add_systems&lt;on_state_enter&gt;(Schedule::UPDATE)
        .run_if&lt;state_changed&lt;AppState&gt;&gt;()
    
    // ExÃ©cuter quand un Ã©vÃ©nement est prÃ©sent
    .add_systems&lt;handle_collision&gt;(Schedule::UPDATE)
        .run_if&lt;on_event&lt;CollisionEvent&gt;&gt;()
    
    // ExÃ©cuter si une ressource existe
    .add_systems&lt;use_resource&gt;(Schedule::UPDATE)
        .run_if&lt;resource_exists&lt;MyResource&gt;&gt;()
    
    .run();</code></pre>
                </div>

                <h3>Conditions PersonnalisÃ©es</h3>
                <div class="code-block">
                    <div class="code-header">CrÃ©er une Condition</div>
                    <pre><code class="cpp">// Toute fonction retournant bool peut Ãªtre une condition
bool is_debug_mode(Res&lt;Settings&gt; settings) {
    return settings.ptr->debug_enabled;
}

bool has_enough_resources(Res&lt;PlayerInventory&gt; inventory) {
    return inventory.ptr->gold >= 100;
}

Application{}
    .add_systems&lt;debug_overlay&gt;(Schedule::UPDATE)
        .run_if&lt;is_debug_mode&gt;()
    
    .add_systems&lt;spawn_unit&gt;(Schedule::UPDATE)
        .run_if&lt;has_enough_resources&gt;()
    .run();</code></pre>
                </div>
            </div>

            <!-- Schedules -->
            <div id="schedules" class="subsection">
                <h2>Schedules (Planificateurs)</h2>
                <p>
                    Les schedules organisent l'exÃ©cution des systÃ¨mes en diffÃ©rentes phases.
                    R-Engine fournit plusieurs schedules prÃ©dÃ©finis.
                </p>

                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Schedule</th>
                            <th>Quand</th>
                            <th>Usage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>STARTUP</code></td>
                            <td>Une fois au dÃ©marrage</td>
                            <td>Initialisation, spawn des entitÃ©s initiales</td>
                        </tr>
                        <tr>
                            <td><code>PRE_UPDATE</code></td>
                            <td>Avant UPDATE</td>
                            <td>PrÃ©paration, nettoyage de frame</td>
                        </tr>
                        <tr>
                            <td><code>UPDATE</code></td>
                            <td>Chaque frame</td>
                            <td>Logique du jeu, physique, AI</td>
                        </tr>
                        <tr>
                            <td><code>POST_UPDATE</code></td>
                            <td>AprÃ¨s UPDATE</td>
                            <td>Post-traitement, finalisation</td>
                        </tr>
                        <tr>
                            <td><code>RENDER_2D</code></td>
                            <td>Phase de rendu 2D</td>
                            <td>Dessin 2D (sprites, UI)</td>
                        </tr>
                        <tr>
                            <td><code>RENDER_3D</code></td>
                            <td>Phase de rendu 3D</td>
                            <td>Dessin 3D (modÃ¨les, lumiÃ¨res)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Ordre d'ExÃ©cution</h3>
                <div class="code-block">
                    <div class="code-header">DÃ©finir l'Ordre</div>
                    <pre><code class="cpp">Application{}
    // Les systÃ¨mes s'exÃ©cutent dans l'ordre d'ajout par dÃ©faut
    .add_systems&lt;input, physics, render&gt;(Schedule::UPDATE)
    
    // Forcer l'ordre explicitement
    .add_systems&lt;system_a&gt;(Schedule::UPDATE)
    .add_systems&lt;system_b&gt;(Schedule::UPDATE)
        .after&lt;system_a&gt;()  // system_b aprÃ¨s system_a
    
    .add_systems&lt;system_c&gt;(Schedule::UPDATE)
        .before&lt;system_b&gt;() // system_c avant system_b
    
    .run();</code></pre>
                </div>
            </div>
        </section>

        <!-- Storage System -->
        <section id="storage" class="section">
            <h1>SystÃ¨me de Stockage</h1>
            
            <p>
                R-Engine utilise un stockage basÃ© sur les <strong>archÃ©types</strong> pour optimiser
                les performances. Cette approche organise les entitÃ©s par combinaison unique de composants.
            </p>

            <h2>ArchÃ©types</h2>
            <div class="info-box">
                <p>
                    Un <strong>archetype</strong> reprÃ©sente une combinaison unique de types de composants.
                    Toutes les entitÃ©s avec exactement les mÃªmes composants sont stockÃ©es dans le mÃªme archetype.
                </p>
            </div>

            <div class="code-block">
                <div class="code-header">Exemple d'Organisation</div>
                <pre><code class="cpp">// Archetype 1: [Position, Velocity]
Entity 1: Position, Velocity
Entity 4: Position, Velocity
Entity 7: Position, Velocity

// Archetype 2: [Position, Velocity, Health]
Entity 2: Position, Velocity, Health
Entity 5: Position, Velocity, Health

// Archetype 3: [Position, Sprite]
Entity 3: Position, Sprite
Entity 6: Position, Sprite</code></pre>
            </div>

            <h2>Tables Columnar</h2>
            <p>
                Chaque archetype stocke ses composants dans des colonnes (Structure of Arrays - SoA),
                ce qui optimise la localitÃ© mÃ©moire et permet une vectorisation efficace.
            </p>

            <div class="architecture-diagram">
                <pre class="diagram">
Archetype [Position, Velocity, Health]
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Entities:  [  10,   11,   12,   13,  ...  ] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Position:  [ p10,  p11,  p12,  p13,  ...  ] â”‚ â† Column 0
â”‚ Velocity:  [ v10,  v11,  v12,  v13,  ...  ] â”‚ â† Column 1
â”‚ Health:    [ h10,  h11,  h12,  h13,  ...  ] â”‚ â† Column 2
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </pre>
            </div>

            <h2>Transitions d'ArchÃ©types</h2>
            <p>
                Lorsqu'un composant est ajoutÃ© ou retirÃ© d'une entitÃ©, celle-ci change d'archetype.
                R-Engine utilise un cache (edges) pour optimiser ces transitions frÃ©quentes.
            </p>

            <div class="code-block">
                <div class="code-header">Exemple de Transition</div>
                <pre><code class="cpp">// Entity dans Archetype [Position, Velocity]
Entity e = ...;

// Ajout de Health
commands.entity(e).insert(Health{100});
// â†’ Entity dÃ©placÃ©e vers Archetype [Position, Velocity, Health]

// Retrait de Velocity
commands.entity(e).remove&lt;Velocity&gt;();
// â†’ Entity dÃ©placÃ©e vers Archetype [Position, Health]</code></pre>
            </div>

            <h2>Avantages du SystÃ¨me</h2>
            <ul class="feature-list">
                <li><strong>Cache Locality</strong> : Les donnÃ©es sont contiguÃ«s en mÃ©moire</li>
                <li><strong>ItÃ©ration Rapide</strong> : Les queries n'itÃ¨rent que sur les archÃ©types pertinents</li>
                <li><strong>Pas de Fragmentation</strong> : Swap-and-pop pour les suppressions</li>
                <li><strong>Type Safety</strong> : VÃ©rifications Ã  la compilation</li>
                <li><strong>ScalabilitÃ©</strong> : Performance constante avec beaucoup d'entitÃ©s</li>
            </ul>

            <h2>API Interne</h2>
            <div class="code-block">
                <div class="code-header">Structure Archetype</div>
                <pre><code class="cpp">struct Archetype {
    // Types de composants dans cet archetype
    std::vector&lt;std::type_index&gt; component_types;
    
    // Map: type â†’ index de colonne
    std::unordered_map&lt;std::type_index, usize&gt; component_map;
    
    // Stockage des donnÃ©es
    Table table;
    
    // Cache des transitions
    std::unordered_map&lt;std::type_index, usize&gt; add_edge;
    std::unordered_map&lt;std::type_index, usize&gt; remove_edge;
};</code></pre>
            </div>
        </section>

        <!-- Examples -->
        <section id="examples" class="section">
            <h1>Exemples Complets</h1>

            <div class="subsection">
                <h2>Exemple 1: Bouncing Balls</h2>
                <p>DÃ©mo complÃ¨te d'un systÃ¨me de balles rebondissantes avec physique et rendu.</p>
                
                <div class="code-block">
                    <div class="code-header">Main.cpp</div>
                    <pre><code class="cpp">#include &lt;R-Engine/Application.hpp&gt;
#include &lt;R-Engine/Plugins/DefaultPlugins.hpp&gt;

// Composants
struct Position { Vec2f value; };
struct Velocity { Vec2f value; };
struct Circle { float radius; Color color; };
struct Controllable {};

// Ressources
struct Gravity { Vec2f value = {0.0f, 980.0f}; };

// SystÃ¨me de spawn initial
void spawn_entities(Commands &commands, Res&lt;WindowPluginConfig&gt; win) {
    // Joueur
    commands.spawn(
        Controllable{},
        Circle{20.0f, BLUE},
        Position{{400.0f, 300.0f}},
        Velocity{{0.0f, 0.0f}}
    );
    
    // Balles alÃ©atoires
    for (int i = 0; i &lt; 10; ++i) {
        commands.spawn(
            Position{{rand() % 800, rand() % 300}},
            Velocity{{(rand() % 500) - 250.0f, (rand() % 500) - 250.0f}},
            Circle{(rand() % 20) + 10.0f, /* random color */}
        );
    }
}

// Physique
void apply_gravity(
    Query&lt;Mut&lt;Velocity&gt;, Without&lt;Controllable&gt;&gt; query,
    Res&lt;Gravity&gt; gravity,
    Res&lt;FrameTime&gt; time
) {
    for (auto [vel, _] : query) {
        vel.ptr->value += gravity.ptr->value * time.ptr->delta_time;
    }
}

void move_system(
    Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query,
    Res&lt;FrameTime&gt; time
) {
    for (auto [pos, vel] : query) {
        pos.ptr->value += vel.ptr->value * time.ptr->delta_time;
    }
}

void bounce_system(
    Query&lt;Mut&lt;Position&gt;, Mut&lt;Velocity&gt;, Ref&lt;Circle&gt;&gt; query,
    Res&lt;WindowPluginConfig&gt; win
) {
    for (auto [pos, vel, circle] : query) {
        // Rebond sur les bords
        if (pos.ptr->value.x - circle.ptr->radius &lt; 0) {
            pos.ptr->value.x = circle.ptr->radius;
            vel.ptr->value.x = -vel.ptr->value.x * 0.8f;
        }
        // ... autres bords
    }
}

// Rendu
void render_system(Query&lt;Ref&lt;Position&gt;, Ref&lt;Circle&gt;&gt; query) {
    for (auto [pos, circle] : query) {
        DrawCircleV({pos.ptr->value.x, pos.ptr->value.y}, 
                    circle.ptr->radius, circle.ptr->color);
    }
}

int main() {
    Application{}
        .add_plugins(DefaultPlugins{})
        .insert_resource(Gravity{})
        .add_systems&lt;spawn_entities&gt;(Schedule::STARTUP)
        .add_systems&lt;apply_gravity, move_system, bounce_system&gt;(Schedule::UPDATE)
        .add_systems&lt;render_system&gt;(Schedule::RENDER_2D)
        .run();
}</code></pre>
                </div>
            </div>

            <div class="subsection">
                <h2>Exemple 2: Event System</h2>
                <p>DÃ©monstration du systÃ¨me d'Ã©vÃ©nements pour la communication entre systÃ¨mes.</p>
                
                <div class="code-block">
                    <div class="code-header">Events Example</div>
                    <pre><code class="cpp">// DÃ©finir des Ã©vÃ©nements
struct DamageEvent {
    Entity target;
    float amount;
    Entity source;
};

struct DeathEvent {
    Entity entity;
};

// SystÃ¨me qui gÃ©nÃ¨re des Ã©vÃ©nements
void damage_system(
    Query&lt;Ref&lt;Position&gt;, Ref&lt;Attack&gt;&gt; attackers,
    Query&lt;Entity, Ref&lt;Position&gt;, Ref&lt;Health&gt;&gt; targets,
    EventWriter&lt;DamageEvent&gt; damage_events
) {
    for (auto [atk_pos, attack] : attackers) {
        for (auto target_iter = targets.begin(); 
             target_iter != targets.end(); ++target_iter) {
            Entity target_id = target_iter.entity();
            auto [tgt_pos, health] = *target_iter;
            
            float dist = distance(atk_pos.ptr->value, tgt_pos.ptr->value);
            if (dist &lt; attack.ptr->range) {
                damage_events.send(DamageEvent{
                    .target = target_id,
                    .amount = attack.ptr->damage,
                    .source = /* attacker id */
                });
            }
        }
    }
}

// SystÃ¨me qui rÃ©agit aux Ã©vÃ©nements
void health_system(
    EventReader&lt;DamageEvent&gt; damage_events,
    EventWriter&lt;DeathEvent&gt; death_events,
    Query&lt;Mut&lt;Health&gt;&gt; query
) {
    for (const DamageEvent &event : damage_events) {
        // Trouver l'entitÃ© cible
        for (auto iter = query.begin(); iter != query.end(); ++iter) {
            if (iter.entity() == event.target) {
                auto [health] = *iter;
                health.ptr->current -= event.amount;
                
                if (health.ptr->current &lt;= 0) {
                    death_events.send(DeathEvent{event.target});
                }
                break;
            }
        }
    }
}

void cleanup_system(
    EventReader&lt;DeathEvent&gt; death_events,
    Commands &commands
) {
    for (const DeathEvent &event : death_events) {
        commands.despawn(event.entity);
    }
}

int main() {
    Application{}
        .add_plugins(DefaultPlugins{})
        .add_event&lt;DamageEvent&gt;()
        .add_event&lt;DeathEvent&gt;()
        .add_systems&lt;damage_system, health_system, cleanup_system&gt;(Schedule::UPDATE)
        .run();
}</code></pre>
                </div>
            </div>

            <div class="subsection">
                <h2>Exemple 3: States & Menus</h2>
                <p>Utilisation des Ã©tats pour gÃ©rer diffÃ©rentes phases du jeu.</p>
                
                <div class="code-block">
                    <div class="code-header">States Example</div>
                    <pre><code class="cpp">enum class GameState {
    MainMenu,
    Playing,
    Paused,
    GameOver
};

// SystÃ¨me du menu principal
void main_menu_system(
    Res&lt;UserInput&gt; input,
    ResMut&lt;State&lt;GameState&gt;&gt; state
) {
    DrawText("PRESS ENTER TO START", 200, 300, 40, WHITE);
    
    if (IsKeyPressed(KEY_ENTER)) {
        const_cast&lt;State&lt;GameState&gt;*&gt;(state.ptr)
            ->set(GameState::Playing);
    }
}

// Logique du jeu (seulement en Playing)
void game_logic(Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query) {
    // Logique normale du jeu
}

// Gestion de la pause
void pause_handler(
    Res&lt;UserInput&gt; input,
    ResMut&lt;State&lt;GameState&gt;&gt; state,
    Res&lt;State&lt;GameState&gt;&gt; current_state
) {
    if (IsKeyPressed(KEY_ESCAPE)) {
        auto* mutable_state = const_cast&lt;State&lt;GameState&gt;*&gt;(state.ptr);
        
        if (current_state.ptr->current() == GameState::Playing) {
            mutable_state->set(GameState::Paused);
        } else if (current_state.ptr->current() == GameState::Paused) {
            mutable_state->set(GameState::Playing);
        }
    }
}

// Menu pause
void pause_menu(Res&lt;UserInput&gt; input, ResMut&lt;State&lt;GameState&gt;&gt; state) {
    DrawRectangle(0, 0, 800, 600, Fade(BLACK, 0.7f));
    DrawText("PAUSED", 300, 250, 60, WHITE);
    DrawText("ESC to resume", 300, 350, 30, GRAY);
}

int main() {
    Application{}
        .add_plugins(DefaultPlugins{})
        .insert_resource(State&lt;GameState&gt;{GameState::MainMenu})
        
        // Menu principal
        .add_systems&lt;main_menu_system&gt;(Schedule::UPDATE)
            .run_if&lt;in_state&lt;GameState::MainMenu&gt;&gt;()
        
        // Jeu
        .add_systems&lt;game_logic&gt;(Schedule::UPDATE)
            .run_if&lt;in_state&lt;GameState::Playing&gt;&gt;()
        
        // Pause
        .add_systems&lt;pause_handler&gt;(Schedule::UPDATE)
        .add_systems&lt;pause_menu&gt;(Schedule::RENDER_2D)
            .run_if&lt;in_state&lt;GameState::Paused&gt;&gt;()
        
        .run();
}</code></pre>
                </div>
            </div>
        </section>

        <!-- API Reference -->
        <section id="api-reference" class="section">
            <h1>RÃ©fÃ©rence API ComplÃ¨te</h1>

            <div class="subsection">
                <h2>Scene</h2>
                <p>Container principal de l'ECS.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>MÃ©thode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Entity create_entity()</code></td>
                            <td>CrÃ©e une nouvelle entitÃ© vide</td>
                        </tr>
                        <tr>
                            <td><code>void destroy_entity(Entity e)</code></td>
                            <td>DÃ©truit une entitÃ© et ses composants</td>
                        </tr>
                        <tr>
                            <td><code>void add_component&lt;T&gt;(Entity e, T comp)</code></td>
                            <td>Ajoute un composant Ã  une entitÃ©</td>
                        </tr>
                        <tr>
                            <td><code>void remove_component&lt;T&gt;(Entity e)</code></td>
                            <td>Retire un composant d'une entitÃ©</td>
                        </tr>
                        <tr>
                            <td><code>T* get_component_ptr&lt;T&gt;(Entity e)</code></td>
                            <td>Obtient un pointeur vers un composant</td>
                        </tr>
                        <tr>
                            <td><code>bool has_component&lt;T&gt;(Entity e)</code></td>
                            <td>VÃ©rifie si une entitÃ© a un composant</td>
                        </tr>
                        <tr>
                            <td><code>void insert_resource&lt;T&gt;(T&& r)</code></td>
                            <td>InsÃ¨re une ressource globale</td>
                        </tr>
                        <tr>
                            <td><code>void remove_resource&lt;T&gt;()</code></td>
                            <td>Retire une ressource globale</td>
                        </tr>
                        <tr>
                            <td><code>T* get_resource_ptr&lt;T&gt;()</code></td>
                            <td>Obtient un pointeur vers une ressource</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>Commands</h2>
                <p>Interface pour modifications diffÃ©rÃ©es.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>MÃ©thode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>EntityCommands spawn()</code></td>
                            <td>Spawn une entitÃ© vide</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands spawn(Components...)</code></td>
                            <td>Spawn avec composants initiaux</td>
                        </tr>
                        <tr>
                            <td><code>void despawn(Entity e)</code></td>
                            <td>Planifie la destruction d'une entitÃ©</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands entity(Entity e)</code></td>
                            <td>Obtient un builder pour une entitÃ© existante</td>
                        </tr>
                        <tr>
                            <td><code>void insert_resource&lt;T&gt;(T res)</code></td>
                            <td>Planifie l'insertion d'une ressource</td>
                        </tr>
                        <tr>
                            <td><code>void remove_resource&lt;T&gt;()</code></td>
                            <td>Planifie le retrait d'une ressource</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>EntityCommands</h2>
                <p>Builder pour modification d'entitÃ©s.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>MÃ©thode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>EntityCommands& insert&lt;T&gt;(T comp)</code></td>
                            <td>Ajoute un composant (chainable)</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands& remove&lt;T&gt;()</code></td>
                            <td>Retire un composant (chainable)</td>
                        </tr>
                        <tr>
                            <td><code>Entity id() const</code></td>
                            <td>Retourne l'ID de l'entitÃ©</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands& with_children(Func)</code></td>
                            <td>Ajoute des enfants Ã  l'entitÃ©</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>Query&lt;Wrappers...&gt;</h2>
                <p>ItÃ©ration sur les entitÃ©s.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>MÃ©thode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Iterator begin() const</code></td>
                            <td>DÃ©but de l'itÃ©ration</td>
                        </tr>
                        <tr>
                            <td><code>Iterator end() const</code></td>
                            <td>Fin de l'itÃ©ration</td>
                        </tr>
                        <tr>
                            <td><code>u64 size() const</code></td>
                            <td>Nombre d'entitÃ©s matchÃ©es</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Query::Iterator</h3>
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>MÃ©thode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Entity entity() const</code></td>
                            <td>Obtient l'ID de l'entitÃ© courante</td>
                        </tr>
                        <tr>
                            <td><code>auto operator*()</code></td>
                            <td>Obtient les wrappers de composants</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>EventWriter&lt;T&gt;</h2>
                <p>Envoi d'Ã©vÃ©nements.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>MÃ©thode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>void send(const T& event)</code></td>
                            <td>Envoie un Ã©vÃ©nement (copie)</td>
                        </tr>
                        <tr>
                            <td><code>void send(T&& event)</code></td>
                            <td>Envoie un Ã©vÃ©nement (move)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>EventReader&lt;T&gt;</h2>
                <p>Lecture d'Ã©vÃ©nements.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>MÃ©thode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>bool has_events() const</code></td>
                            <td>VÃ©rifie s'il y a des Ã©vÃ©nements</td>
                        </tr>
                        <tr>
                            <td><code>Iterator begin() const</code></td>
                            <td>DÃ©but de l'itÃ©ration</td>
                        </tr>
                        <tr>
                            <td><code>Iterator end() const</code></td>
                            <td>Fin de l'itÃ©ration</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <footer class="footer">
            <p>&copy; 2025 R-Engine Project. Documentation gÃ©nÃ©rÃ©e pour l'ECS.</p>
        </footer>
    </main>

    <script src="script.js"></script>
</body>
</html>