<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R-Engine ECS Documentation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <nav class="sidebar">
        <div class="logo">
            <h1>R-Engine</h1>
            <p>ECS Documentation</p>
        </div>
        <ul class="nav-menu">
            <li><a href="#introduction">Introduction</a></li>
            <li><a href="#architecture">Architecture</a></li>
            <li><a href="#core-concepts">Concepts Clés</a>
                <ul>
                    <li><a href="#entities">Entities</a></li>
                    <li><a href="#components">Components</a></li>
                    <li><a href="#systems">Systems</a></li>
                    <li><a href="#resources">Resources</a></li>
                    <li><a href="#queries">Queries</a></li>
                    <li><a href="#commands">Commands</a></li>
                </ul>
            </li>
            <li><a href="#advanced">Fonctionnalités Avancées</a>
                <ul>
                    <li><a href="#events">Events</a></li>
                    <li><a href="#hierarchies">Hierarchies</a></li>
                    <li><a href="#run-conditions">Run Conditions</a></li>
                    <li><a href="#schedules">Schedules</a></li>
                </ul>
            </li>
            <li><a href="#storage">Système de Stockage</a></li>
            <li><a href="#examples">Exemples</a></li>
            <li><a href="#api-reference">Référence API</a></li>
        </ul>
    </nav>

    <main class="content">
        <!-- Introduction -->
        <section id="introduction" class="section">
            <h1>Introduction à l'ECS R-Engine</h1>
            <p class="lead">
                R-Engine utilise une architecture <strong>Entity Component System (ECS)</strong> inspirée de Bevy, 
                conçue pour offrir performance, flexibilité et simplicité d'utilisation.
            </p>
            
            <div class="info-box">
                <h3>Qu'est-ce qu'un ECS ?</h3>
                <p>
                    Un ECS est un patron de conception architectural qui sépare les données (Components) 
                    de la logique (Systems), en les reliant via des entités (Entities). Cette approche 
                    favorise la composition plutôt que l'héritage et permet un code plus modulaire et performant.
                </p>
            </div>

            <h2>Caractéristiques Principales</h2>
            <ul class="feature-list">
                <li><strong>Archétype-based Storage</strong> : Stockage optimisé par archétype pour des performances maximales</li>
                <li><strong>Type Safety</strong> : Système de types compile-time pour éviter les erreurs</li>
                <li><strong>Dependency Injection</strong> : Résolution automatique des dépendances système</li>
                <li><strong>Command Buffer</strong> : Modifications différées pour éviter l'invalidation des itérateurs</li>
                <li><strong>Events System</strong> : Communication asynchrone entre systèmes</li>
                <li><strong>Hierarchy Support</strong> : Relations parent-enfant natives</li>
            </ul>
        </section>

        <!-- Architecture -->
        <section id="architecture" class="section">
            <h1>Architecture du Système</h1>
            
            <div class="architecture-diagram">
                <pre class="diagram">
┌─────────────────────────────────────────────────────┐
│                   Application                        │
│  ┌───────────────────────────────────────────────┐  │
│  │              Scene (ECS World)                 │  │
│  │  ┌──────────────────────────────────────────┐ │  │
│  │  │         Archetype Storage                 │ │  │
│  │  │  ┌────────────┬────────────┬───────────┐ │ │  │
│  │  │  │ Archetype  │ Archetype  │ Archetype │ │ │  │
│  │  │  │   [A,B]    │   [A,C]    │   [B,C]   │ │ │  │
│  │  │  └────────────┴────────────┴───────────┘ │ │  │
│  │  │         Resources (Global Data)          │ │  │
│  │  │         Entity Locations Map             │ │  │
│  │  └──────────────────────────────────────────┘ │  │
│  │                                                │  │
│  │  ┌──────────────────────────────────────────┐ │  │
│  │  │          System Scheduler                 │ │  │
│  │  │  • STARTUP Systems                        │ │  │
│  │  │  • UPDATE Systems                         │ │  │
│  │  │  • RENDER Systems                         │ │  │
│  │  └──────────────────────────────────────────┘ │  │
│  │                                                │  │
│  │  ┌──────────────────────────────────────────┐ │  │
│  │  │          Command Buffer                   │ │  │
│  │  │  Queue de modifications différées         │ │  │
│  │  └──────────────────────────────────────────┘ │  │
│  └───────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                </pre>
            </div>

            <h2>Flux d'Exécution</h2>
            <ol class="execution-flow">
                <li><strong>Initialisation</strong> : Création de la Scene et exécution des systèmes STARTUP</li>
                <li><strong>Boucle Principale</strong> :
                    <ol>
                        <li>Exécution des systèmes UPDATE (logique du jeu)</li>
                        <li>Application du Command Buffer (modifications structurelles)</li>
                        <li>Exécution des systèmes RENDER (affichage)</li>
                        <li>Update des Events (double buffering)</li>
                    </ol>
                </li>
            </ol>
        </section>

        <!-- Core Concepts -->
        <section id="core-concepts" class="section">
            <h1>Concepts Clés</h1>

            <!-- Entities -->
            <div id="entities" class="subsection">
                <h2>Entities (Entités)</h2>
                <p>
                    Une entité est simplement un identifiant unique (<code>u32</code>) qui regroupe des composants.
                    Elle n'a pas de données ou de comportement propre.
                </p>
                
                <div class="code-block">
                    <div class="code-header">Entity.hpp</div>
                    <pre><code class="cpp">namespace r::ecs {
    using Entity = u32;
    static constexpr Entity NULL_ENTITY = static_cast&lt;Entity&gt;(-1);
}</code></pre>
                </div>

                <h3>Création d'Entités</h3>
                <div class="code-block">
                    <div class="code-header">Exemple</div>
                    <pre><code class="cpp">void spawn_system(Commands &commands) {
    // Créer une entité vide
    Entity entity = commands.spawn().id();
    
    // Créer une entité avec des composants
    commands.spawn(
        Position{0.0f, 0.0f},
        Velocity{1.0f, 0.0f},
        Health{100}
    );
}</code></pre>
                </div>
            </div>

            <!-- Components -->
            <div id="components" class="subsection">
                <h2>Components (Composants)</h2>
                <p>
                    Les composants sont des structures de données pures qui définissent les propriétés d'une entité.
                    Ils ne contiennent pas de logique, seulement des données.
                </p>

                <div class="best-practices">
                    <h3>Bonnes Pratiques</h3>
                    <ul>
                        <li>Garder les composants simples et focused</li>
                        <li>Utiliser des structs POD (Plain Old Data) autant que possible</li>
                        <li>Préférer plusieurs petits composants à un gros composant monolithique</li>
                        <li>Utiliser des marker components (sans données) pour taguer des entités</li>
                    </ul>
                </div>

                <div class="code-block">
                    <div class="code-header">Exemples de Composants</div>
                    <pre><code class="cpp">// Composant de données
struct Position {
    Vec2f value;
};

// Composant de données
struct Velocity {
    Vec2f value;
};

// Composant graphique
struct Circle {
    float radius;
    Color color;
};

// Marker component (sans données)
struct Player {};

// Composant complexe
struct Health {
    float current;
    float max;
    
    bool is_alive() const { return current > 0.0f; }
    float percentage() const { return current / max; }
};</code></pre>
                </div>
            </div>

            <!-- Systems -->
            <div id="systems" class="subsection">
                <h2>Systems (Systèmes)</h2>
                <p>
                    Les systèmes sont des fonctions qui implémentent la logique de votre application.
                    Ils opèrent sur des entités via des queries et peuvent accéder aux ressources globales.
                </p>

                <h3>Anatomie d'un Système</h3>
                <div class="code-block">
                    <div class="code-header">Structure de Base</div>
                    <pre><code class="cpp">// Système simple
void movement_system(
    Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query,
    Res&lt;FrameTime&gt; time
) {
    for (auto [pos, vel] : query) {
        pos.ptr->value += vel.ptr->value * time.ptr->delta_time;
    }
}</code></pre>
                </div>

                <h3>Paramètres de Système</h3>
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Description</th>
                            <th>Utilisation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Query&lt;...&gt;</code></td>
                            <td>Itérer sur des entités avec certains composants</td>
                            <td>Logique sur plusieurs entités</td>
                        </tr>
                        <tr>
                            <td><code>Res&lt;T&gt;</code></td>
                            <td>Accès lecture seule à une ressource</td>
                            <td>Lire configuration, temps, etc.</td>
                        </tr>
                        <tr>
                            <td><code>ResMut&lt;T&gt;</code></td>
                            <td>Accès mutable à une ressource</td>
                            <td>Modifier état global</td>
                        </tr>
                        <tr>
                            <td><code>Commands</code></td>
                            <td>Buffer de commandes différées</td>
                            <td>Spawn, despawn, add/remove components</td>
                        </tr>
                        <tr>
                            <td><code>EventWriter&lt;T&gt;</code></td>
                            <td>Envoyer des événements</td>
                            <td>Communication asynchrone</td>
                        </tr>
                        <tr>
                            <td><code>EventReader&lt;T&gt;</code></td>
                            <td>Lire des événements</td>
                            <td>Réagir aux événements</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <div class="code-header">Exemple Complet</div>
                    <pre><code class="cpp">void complex_system(
    Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;, With&lt;Player&gt;&gt; query,
    Res&lt;FrameTime&gt; time,
    Res&lt;UserInput&gt; input,
    Commands &commands,
    EventWriter&lt;CollisionEvent&gt; collision_events
) {
    for (auto [pos, vel, _] : query) {
        // Logique du système...
        pos.ptr->value += vel.ptr->value * time.ptr->delta_time;
        
        // Envoyer un événement
        collision_events.send(CollisionEvent{/* ... */});
        
        // Spawn une nouvelle entité
        commands.spawn(Particle{/* ... */});
    }
}</code></pre>
                </div>

                <h3>Enregistrement des Systèmes</h3>
                <div class="code-block">
                    <div class="code-header">Application.cpp</div>
                    <pre><code class="cpp">Application{}
    // Systèmes STARTUP (exécutés une fois au démarrage)
    .add_systems&lt;setup_system, spawn_entities&gt;(Schedule::STARTUP)
    
    // Systèmes UPDATE (exécutés chaque frame)
    .add_systems&lt;
        input_system,
        movement_system,
        collision_system
    &gt;(Schedule::UPDATE)
    
    // Définir l'ordre d'exécution
    .after&lt;input_system&gt;()
    
    // Systèmes RENDER
    .add_systems&lt;render_system&gt;(Schedule::RENDER_2D)
    .run();</code></pre>
                </div>
            </div>

            <!-- Resources -->
            <div id="resources" class="subsection">
                <h2>Resources (Ressources)</h2>
                <p>
                    Les ressources sont des données globales, uniques, accessibles par tous les systèmes.
                    Elles sont parfaites pour stocker la configuration, l'état global, ou des services.
                </p>

                <div class="code-block">
                    <div class="code-header">Définition et Utilisation</div>
                    <pre><code class="cpp">// Définir une ressource
struct GameConfig {
    float gravity = 9.81f;
    int max_enemies = 100;
};

// Insérer dans l'application
Application{}
    .insert_resource(GameConfig{})
    .run();

// Accéder en lecture seule
void physics_system(Res&lt;GameConfig&gt; config) {
    float g = config.ptr->gravity;
}

// Accéder en écriture
void difficulty_system(ResMut&lt;GameConfig&gt; config) {
    config.ptr->max_enemies = 150;
}

// Ajouter/retirer dynamiquement
void management_system(Commands &commands) {
    commands.insert_resource(NewResource{});
    commands.remove_resource&lt;OldResource&gt;();
}</code></pre>
                </div>
            </div>

            <!-- Queries -->
            <div id="queries" class="subsection">
                <h2>Queries (Requêtes)</h2>
                <p>
                    Les queries permettent d'itérer sur des entités qui correspondent à certains critères.
                    Elles supportent plusieurs types de filtres et d'accès.
                </p>

                <h3>Types d'Accès</h3>
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Wrapper</th>
                            <th>Description</th>
                            <th>Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Mut&lt;T&gt;</code></td>
                            <td>Accès mutable au composant T</td>
                            <td><code>Mut&lt;Position&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>Ref&lt;T&gt;</code></td>
                            <td>Accès lecture seule au composant T</td>
                            <td><code>Ref&lt;Velocity&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>With&lt;T&gt;</code></td>
                            <td>Filtre: requiert le composant T (sans accès)</td>
                            <td><code>With&lt;Player&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>Without&lt;T&gt;</code></td>
                            <td>Filtre: exclut les entités avec T</td>
                            <td><code>Without&lt;Dead&gt;</code></td>
                        </tr>
                        <tr>
                            <td><code>Optional&lt;T&gt;</code></td>
                            <td>Accès optionnel (nullptr si absent)</td>
                            <td><code>Optional&lt;Armor&gt;</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <div class="code-header">Exemples de Queries</div>
                    <pre><code class="cpp">// Query simple: toutes les entités avec Position
void simple(Query&lt;Ref&lt;Position&gt;&gt; query) {
    for (auto [pos] : query) {
        // pos.ptr est const Position*
    }
}

// Query avec modification
void movement(Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query) {
    for (auto [pos, vel] : query) {
        pos.ptr->value += vel.ptr->value;
    }
}

// Query avec filtres
void player_only(Query&lt;Mut&lt;Health&gt;, With&lt;Player&gt;&gt; query) {
    for (auto [health, _] : query) {
        // Seulement les entités Player
    }
}

// Exclure certaines entités
void alive_enemies(
    Query&lt;Ref&lt;Position&gt;, With&lt;Enemy&gt;, Without&lt;Dead&gt;&gt; query
) {
    for (auto [pos, _, __] : query) {
        // Ennemis vivants uniquement
    }
}

// Composants optionnels
void render(Query&lt;Ref&lt;Position&gt;, Optional&lt;Sprite&gt;&gt; query) {
    for (auto [pos, sprite_opt] : query) {
        if (sprite_opt.ptr != nullptr) {
            // Entité a un sprite
        } else {
            // Pas de sprite
        }
    }
}

// Récupérer l'ID de l'entité
void id_access(Query&lt;Ref&lt;Health&gt;&gt; query) {
    for (auto iter = query.begin(); iter != query.end(); ++iter) {
        Entity e = iter.entity();
        auto [health] = *iter;
    }
}</code></pre>
                </div>

                <div class="warning-box">
                    <h4>⚠️ Important</h4>
                    <p>
                        Ne modifiez jamais la structure de l'ECS (spawn, despawn, add/remove components)
                        pendant l'itération d'une query. Utilisez plutôt <code>Commands</code> pour
                        différer ces opérations.
                    </p>
                </div>
            </div>

            <!-- Commands -->
            <div id="commands" class="subsection">
                <h2>Commands (Commandes)</h2>
                <p>
                    Le système de commandes permet de différer les modifications structurelles de l'ECS
                    (création/destruction d'entités, ajout/suppression de composants) pour éviter
                    l'invalidation des itérateurs pendant l'exécution des systèmes.
                </p>

                <h3>API des Commandes</h3>
                <div class="code-block">
                    <div class="code-header">Opérations Disponibles</div>
                    <pre><code class="cpp">void example_system(Commands &commands) {
    // ===== Gestion des Entités =====
    
    // Spawn une entité vide
    Entity e1 = commands.spawn().id();
    
    // Spawn avec composants
    EntityCommands entity = commands.spawn(
        Position{0, 0},
        Velocity{1, 1}
    );
    
    // Chaînage de commandes
    commands.spawn()
        .insert(Position{10, 10})
        .insert(Velocity{0, 1})
        .insert(Health{100});
    
    // Despawn une entité
    commands.despawn(entity_id);
    
    // ===== Gestion des Composants =====
    
    // Ajouter un composant
    commands.entity(entity_id).insert(NewComponent{});
    commands.add_component(entity_id, Armor{50});
    
    // Retirer un composant
    commands.entity(entity_id).remove&lt;OldComponent&gt;();
    
    // ===== Gestion des Ressources =====
    
    // Insérer une ressource
    commands.insert_resource(GameState{});
    
    // Retirer une ressource
    commands.remove_resource&lt;GameState&gt;();
}</code></pre>
                </div>

                <h3>Hiérarchies Parent-Enfant</h3>
                <div class="code-block">
                    <div class="code-header">Relations Hiérarchiques</div>
                    <pre><code class="cpp">void spawn_hierarchy(Commands &commands) {
    // Méthode 1: with_children
    commands.spawn(Transform{})
        .with_children([](ChildBuilder &builder) {
            builder.spawn(ChildTransform{});
            builder.spawn(ChildTransform{});
        });
    
    // Méthode 2: Manuelle
    Entity parent = commands.spawn(Transform{}).id();
    Entity child1 = commands.spawn(ChildTransform{}).id();
    Entity child2 = commands.spawn(ChildTransform{}).id();
    
    commands.add_child(parent, child1);
    commands.add_child(parent, child2);
}</code></pre>
                </div>

                <div class="info-box">
                    <h4>💡 Moment d'Application</h4>
                    <p>
                        Toutes les commandes sont appliquées automatiquement à la fin du schedule courant,
                        juste avant l'application suivante des systèmes. Vous n'avez pas besoin d'appeler
                        manuellement <code>apply()</code>.
                    </p>
                </div>
            </div>
        </section>

        <!-- Advanced Features -->
        <section id="advanced" class="section">
            <h1>Fonctionnalités Avancées</h1>

            <!-- Events -->
            <div id="events" class="subsection">
                <h2>Events (Événements)</h2>
                <p>
                    Le système d'événements permet une communication asynchrone entre systèmes.
                    Les événements utilisent un double buffering: les événements envoyés à la frame N
                    sont lisibles à la frame N+1.
                </p>

                <div class="code-block">
                    <div class="code-header">Définition et Utilisation</div>
                    <pre><code class="cpp">// 1. Définir un type d'événement
struct CollisionEvent {
    Entity entity_a;
    Entity entity_b;
    Vec2f point;
};

// 2. Ajouter le plugin Events à l'application
Application{}
    .add_event&lt;CollisionEvent&gt;()
    .run();

// 3. Envoyer des événements
void collision_detection(EventWriter&lt;CollisionEvent&gt; writer) {
    // Détection de collision...
    writer.send(CollisionEvent{
        .entity_a = entity1,
        .entity_b = entity2,
        .point = {10.0f, 20.0f}
    });
}

// 4. Lire des événements
void collision_response(EventReader&lt;CollisionEvent&gt; reader) {
    // Vérifier s'il y a des événements
    if (!reader.has_events()) {
        return;
    }
    
    // Itérer sur les événements
    for (const CollisionEvent &event : reader) {
        std::cout << "Collision at: " 
                  << event.point.x << ", " 
                  << event.point.y << std::endl;
    }
}</code></pre>
                </div>

                <div class="warning-box">
                    <h4>⚠️ Durée de Vie</h4>
                    <p>
                        Les événements ne persistent qu'une seule frame. Ils sont automatiquement
                        nettoyés au début de chaque nouveau cycle de frame.
                    </p>
                </div>
            </div>

            <!-- Hierarchies -->
            <div id="hierarchies" class="subsection">
                <h2>Hierarchies (Hiérarchies)</h2>
                <p>
                    R-Engine supporte nativement les relations parent-enfant via les composants
                    <code>Parent</code> et <code>Children</code>.
                </p>

                <div class="code-block">
                    <div class="code-header">Composants de Hiérarchie</div>
                    <pre><code class="cpp">// Composants automatiques
struct Parent {
    Entity entity;  // L'entité parente
};

struct Children {
    std::vector&lt;Entity&gt; entities;  // Les enfants
};

// Création d'une hiérarchie
void spawn_player(Commands &commands) {
    commands.spawn(PlayerController{})
        .with_children([](ChildBuilder &builder) {
            // Arme
            builder.spawn(Weapon{});
            
            // Modèle 3D
            builder.spawn(Model{});
            
            // Particules
            builder.spawn(ParticleEmitter{});
        });
}

// Parcourir une hiérarchie
void traverse_hierarchy(
    Query&lt;Ref&lt;Children&gt;&gt; parents_query,
    Query&lt;Ref&lt;Transform&gt;&gt; transforms_query
) {
    for (auto [children] : parents_query) {
        for (Entity child : children.ptr->entities) {
            // Traiter chaque enfant
        }
    }
}</code></pre>
                </div>
            </div>

            <!-- Run Conditions -->
            <div id="run-conditions" class="subsection">
                <h2>Run Conditions (Conditions d'Exécution)</h2>
                <p>
                    Les run conditions permettent d'exécuter des systèmes conditionnellement,
                    en fonction de l'état de l'application ou de la présence d'événements.
                </p>

                <div class="code-block">
                    <div class="code-header">Conditions Disponibles</div>
                    <pre><code class="cpp">// Définir un état
enum class AppState {
    MainMenu,
    Playing,
    Paused
};

Application{}
    .insert_resource(State&lt;AppState&gt;{AppState::MainMenu})
    
    // Exécuter seulement dans un état spécifique
    .add_systems&lt;game_logic&gt;(Schedule::UPDATE)
        .run_if&lt;in_state&lt;AppState::Playing&gt;&gt;()
    
    // Exécuter quand l'état change
    .add_systems&lt;on_state_enter&gt;(Schedule::UPDATE)
        .run_if&lt;state_changed&lt;AppState&gt;&gt;()
    
    // Exécuter quand un événement est présent
    .add_systems&lt;handle_collision&gt;(Schedule::UPDATE)
        .run_if&lt;on_event&lt;CollisionEvent&gt;&gt;()
    
    // Exécuter si une ressource existe
    .add_systems&lt;use_resource&gt;(Schedule::UPDATE)
        .run_if&lt;resource_exists&lt;MyResource&gt;&gt;()
    
    .run();</code></pre>
                </div>

                <h3>Conditions Personnalisées</h3>
                <div class="code-block">
                    <div class="code-header">Créer une Condition</div>
                    <pre><code class="cpp">// Toute fonction retournant bool peut être une condition
bool is_debug_mode(Res&lt;Settings&gt; settings) {
    return settings.ptr->debug_enabled;
}

bool has_enough_resources(Res&lt;PlayerInventory&gt; inventory) {
    return inventory.ptr->gold >= 100;
}

Application{}
    .add_systems&lt;debug_overlay&gt;(Schedule::UPDATE)
        .run_if&lt;is_debug_mode&gt;()
    
    .add_systems&lt;spawn_unit&gt;(Schedule::UPDATE)
        .run_if&lt;has_enough_resources&gt;()
    .run();</code></pre>
                </div>
            </div>

            <!-- Schedules -->
            <div id="schedules" class="subsection">
                <h2>Schedules (Planificateurs)</h2>
                <p>
                    Les schedules organisent l'exécution des systèmes en différentes phases.
                    R-Engine fournit plusieurs schedules prédéfinis.
                </p>

                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Schedule</th>
                            <th>Quand</th>
                            <th>Usage</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>STARTUP</code></td>
                            <td>Une fois au démarrage</td>
                            <td>Initialisation, spawn des entités initiales</td>
                        </tr>
                        <tr>
                            <td><code>PRE_UPDATE</code></td>
                            <td>Avant UPDATE</td>
                            <td>Préparation, nettoyage de frame</td>
                        </tr>
                        <tr>
                            <td><code>UPDATE</code></td>
                            <td>Chaque frame</td>
                            <td>Logique du jeu, physique, AI</td>
                        </tr>
                        <tr>
                            <td><code>POST_UPDATE</code></td>
                            <td>Après UPDATE</td>
                            <td>Post-traitement, finalisation</td>
                        </tr>
                        <tr>
                            <td><code>RENDER_2D</code></td>
                            <td>Phase de rendu 2D</td>
                            <td>Dessin 2D (sprites, UI)</td>
                        </tr>
                        <tr>
                            <td><code>RENDER_3D</code></td>
                            <td>Phase de rendu 3D</td>
                            <td>Dessin 3D (modèles, lumières)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Ordre d'Exécution</h3>
                <div class="code-block">
                    <div class="code-header">Définir l'Ordre</div>
                    <pre><code class="cpp">Application{}
    // Les systèmes s'exécutent dans l'ordre d'ajout par défaut
    .add_systems&lt;input, physics, render&gt;(Schedule::UPDATE)
    
    // Forcer l'ordre explicitement
    .add_systems&lt;system_a&gt;(Schedule::UPDATE)
    .add_systems&lt;system_b&gt;(Schedule::UPDATE)
        .after&lt;system_a&gt;()  // system_b après system_a
    
    .add_systems&lt;system_c&gt;(Schedule::UPDATE)
        .before&lt;system_b&gt;() // system_c avant system_b
    
    .run();</code></pre>
                </div>
            </div>
        </section>

        <!-- Storage System -->
        <section id="storage" class="section">
            <h1>Système de Stockage</h1>
            
            <p>
                R-Engine utilise un stockage basé sur les <strong>archétypes</strong> pour optimiser
                les performances. Cette approche organise les entités par combinaison unique de composants.
            </p>

            <h2>Archétypes</h2>
            <div class="info-box">
                <p>
                    Un <strong>archetype</strong> représente une combinaison unique de types de composants.
                    Toutes les entités avec exactement les mêmes composants sont stockées dans le même archetype.
                </p>
            </div>

            <div class="code-block">
                <div class="code-header">Exemple d'Organisation</div>
                <pre><code class="cpp">// Archetype 1: [Position, Velocity]
Entity 1: Position, Velocity
Entity 4: Position, Velocity
Entity 7: Position, Velocity

// Archetype 2: [Position, Velocity, Health]
Entity 2: Position, Velocity, Health
Entity 5: Position, Velocity, Health

// Archetype 3: [Position, Sprite]
Entity 3: Position, Sprite
Entity 6: Position, Sprite</code></pre>
            </div>

            <h2>Tables Columnar</h2>
            <p>
                Chaque archetype stocke ses composants dans des colonnes (Structure of Arrays - SoA),
                ce qui optimise la localité mémoire et permet une vectorisation efficace.
            </p>

            <div class="architecture-diagram">
                <pre class="diagram">
Archetype [Position, Velocity, Health]
┌─────────────────────────────────────────────┐
│ Entities:  [  10,   11,   12,   13,  ...  ] │
├─────────────────────────────────────────────┤
│ Position:  [ p10,  p11,  p12,  p13,  ...  ] │ ← Column 0
│ Velocity:  [ v10,  v11,  v12,  v13,  ...  ] │ ← Column 1
│ Health:    [ h10,  h11,  h12,  h13,  ...  ] │ ← Column 2
└─────────────────────────────────────────────┘
                </pre>
            </div>

            <h2>Transitions d'Archétypes</h2>
            <p>
                Lorsqu'un composant est ajouté ou retiré d'une entité, celle-ci change d'archetype.
                R-Engine utilise un cache (edges) pour optimiser ces transitions fréquentes.
            </p>

            <div class="code-block">
                <div class="code-header">Exemple de Transition</div>
                <pre><code class="cpp">// Entity dans Archetype [Position, Velocity]
Entity e = ...;

// Ajout de Health
commands.entity(e).insert(Health{100});
// → Entity déplacée vers Archetype [Position, Velocity, Health]

// Retrait de Velocity
commands.entity(e).remove&lt;Velocity&gt;();
// → Entity déplacée vers Archetype [Position, Health]</code></pre>
            </div>

            <h2>Avantages du Système</h2>
            <ul class="feature-list">
                <li><strong>Cache Locality</strong> : Les données sont contiguës en mémoire</li>
                <li><strong>Itération Rapide</strong> : Les queries n'itèrent que sur les archétypes pertinents</li>
                <li><strong>Pas de Fragmentation</strong> : Swap-and-pop pour les suppressions</li>
                <li><strong>Type Safety</strong> : Vérifications à la compilation</li>
                <li><strong>Scalabilité</strong> : Performance constante avec beaucoup d'entités</li>
            </ul>

            <h2>API Interne</h2>
            <div class="code-block">
                <div class="code-header">Structure Archetype</div>
                <pre><code class="cpp">struct Archetype {
    // Types de composants dans cet archetype
    std::vector&lt;std::type_index&gt; component_types;
    
    // Map: type → index de colonne
    std::unordered_map&lt;std::type_index, usize&gt; component_map;
    
    // Stockage des données
    Table table;
    
    // Cache des transitions
    std::unordered_map&lt;std::type_index, usize&gt; add_edge;
    std::unordered_map&lt;std::type_index, usize&gt; remove_edge;
};</code></pre>
            </div>
        </section>

        <!-- Examples -->
        <section id="examples" class="section">
            <h1>Exemples Complets</h1>

            <div class="subsection">
                <h2>Exemple 1: Bouncing Balls</h2>
                <p>Démo complète d'un système de balles rebondissantes avec physique et rendu.</p>
                
                <div class="code-block">
                    <div class="code-header">Main.cpp</div>
                    <pre><code class="cpp">#include &lt;R-Engine/Application.hpp&gt;
#include &lt;R-Engine/Plugins/DefaultPlugins.hpp&gt;

// Composants
struct Position { Vec2f value; };
struct Velocity { Vec2f value; };
struct Circle { float radius; Color color; };
struct Controllable {};

// Ressources
struct Gravity { Vec2f value = {0.0f, 980.0f}; };

// Système de spawn initial
void spawn_entities(Commands &commands, Res&lt;WindowPluginConfig&gt; win) {
    // Joueur
    commands.spawn(
        Controllable{},
        Circle{20.0f, BLUE},
        Position{{400.0f, 300.0f}},
        Velocity{{0.0f, 0.0f}}
    );
    
    // Balles aléatoires
    for (int i = 0; i &lt; 10; ++i) {
        commands.spawn(
            Position{{rand() % 800, rand() % 300}},
            Velocity{{(rand() % 500) - 250.0f, (rand() % 500) - 250.0f}},
            Circle{(rand() % 20) + 10.0f, /* random color */}
        );
    }
}

// Physique
void apply_gravity(
    Query&lt;Mut&lt;Velocity&gt;, Without&lt;Controllable&gt;&gt; query,
    Res&lt;Gravity&gt; gravity,
    Res&lt;FrameTime&gt; time
) {
    for (auto [vel, _] : query) {
        vel.ptr->value += gravity.ptr->value * time.ptr->delta_time;
    }
}

void move_system(
    Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query,
    Res&lt;FrameTime&gt; time
) {
    for (auto [pos, vel] : query) {
        pos.ptr->value += vel.ptr->value * time.ptr->delta_time;
    }
}

void bounce_system(
    Query&lt;Mut&lt;Position&gt;, Mut&lt;Velocity&gt;, Ref&lt;Circle&gt;&gt; query,
    Res&lt;WindowPluginConfig&gt; win
) {
    for (auto [pos, vel, circle] : query) {
        // Rebond sur les bords
        if (pos.ptr->value.x - circle.ptr->radius &lt; 0) {
            pos.ptr->value.x = circle.ptr->radius;
            vel.ptr->value.x = -vel.ptr->value.x * 0.8f;
        }
        // ... autres bords
    }
}

// Rendu
void render_system(Query&lt;Ref&lt;Position&gt;, Ref&lt;Circle&gt;&gt; query) {
    for (auto [pos, circle] : query) {
        DrawCircleV({pos.ptr->value.x, pos.ptr->value.y}, 
                    circle.ptr->radius, circle.ptr->color);
    }
}

int main() {
    Application{}
        .add_plugins(DefaultPlugins{})
        .insert_resource(Gravity{})
        .add_systems&lt;spawn_entities&gt;(Schedule::STARTUP)
        .add_systems&lt;apply_gravity, move_system, bounce_system&gt;(Schedule::UPDATE)
        .add_systems&lt;render_system&gt;(Schedule::RENDER_2D)
        .run();
}</code></pre>
                </div>
            </div>

            <div class="subsection">
                <h2>Exemple 2: Event System</h2>
                <p>Démonstration du système d'événements pour la communication entre systèmes.</p>
                
                <div class="code-block">
                    <div class="code-header">Events Example</div>
                    <pre><code class="cpp">// Définir des événements
struct DamageEvent {
    Entity target;
    float amount;
    Entity source;
};

struct DeathEvent {
    Entity entity;
};

// Système qui génère des événements
void damage_system(
    Query&lt;Ref&lt;Position&gt;, Ref&lt;Attack&gt;&gt; attackers,
    Query&lt;Entity, Ref&lt;Position&gt;, Ref&lt;Health&gt;&gt; targets,
    EventWriter&lt;DamageEvent&gt; damage_events
) {
    for (auto [atk_pos, attack] : attackers) {
        for (auto target_iter = targets.begin(); 
             target_iter != targets.end(); ++target_iter) {
            Entity target_id = target_iter.entity();
            auto [tgt_pos, health] = *target_iter;
            
            float dist = distance(atk_pos.ptr->value, tgt_pos.ptr->value);
            if (dist &lt; attack.ptr->range) {
                damage_events.send(DamageEvent{
                    .target = target_id,
                    .amount = attack.ptr->damage,
                    .source = /* attacker id */
                });
            }
        }
    }
}

// Système qui réagit aux événements
void health_system(
    EventReader&lt;DamageEvent&gt; damage_events,
    EventWriter&lt;DeathEvent&gt; death_events,
    Query&lt;Mut&lt;Health&gt;&gt; query
) {
    for (const DamageEvent &event : damage_events) {
        // Trouver l'entité cible
        for (auto iter = query.begin(); iter != query.end(); ++iter) {
            if (iter.entity() == event.target) {
                auto [health] = *iter;
                health.ptr->current -= event.amount;
                
                if (health.ptr->current &lt;= 0) {
                    death_events.send(DeathEvent{event.target});
                }
                break;
            }
        }
    }
}

void cleanup_system(
    EventReader&lt;DeathEvent&gt; death_events,
    Commands &commands
) {
    for (const DeathEvent &event : death_events) {
        commands.despawn(event.entity);
    }
}

int main() {
    Application{}
        .add_plugins(DefaultPlugins{})
        .add_event&lt;DamageEvent&gt;()
        .add_event&lt;DeathEvent&gt;()
        .add_systems&lt;damage_system, health_system, cleanup_system&gt;(Schedule::UPDATE)
        .run();
}</code></pre>
                </div>
            </div>

            <div class="subsection">
                <h2>Exemple 3: States & Menus</h2>
                <p>Utilisation des états pour gérer différentes phases du jeu.</p>
                
                <div class="code-block">
                    <div class="code-header">States Example</div>
                    <pre><code class="cpp">enum class GameState {
    MainMenu,
    Playing,
    Paused,
    GameOver
};

// Système du menu principal
void main_menu_system(
    Res&lt;UserInput&gt; input,
    ResMut&lt;State&lt;GameState&gt;&gt; state
) {
    DrawText("PRESS ENTER TO START", 200, 300, 40, WHITE);
    
    if (IsKeyPressed(KEY_ENTER)) {
        const_cast&lt;State&lt;GameState&gt;*&gt;(state.ptr)
            ->set(GameState::Playing);
    }
}

// Logique du jeu (seulement en Playing)
void game_logic(Query&lt;Mut&lt;Position&gt;, Ref&lt;Velocity&gt;&gt; query) {
    // Logique normale du jeu
}

// Gestion de la pause
void pause_handler(
    Res&lt;UserInput&gt; input,
    ResMut&lt;State&lt;GameState&gt;&gt; state,
    Res&lt;State&lt;GameState&gt;&gt; current_state
) {
    if (IsKeyPressed(KEY_ESCAPE)) {
        auto* mutable_state = const_cast&lt;State&lt;GameState&gt;*&gt;(state.ptr);
        
        if (current_state.ptr->current() == GameState::Playing) {
            mutable_state->set(GameState::Paused);
        } else if (current_state.ptr->current() == GameState::Paused) {
            mutable_state->set(GameState::Playing);
        }
    }
}

// Menu pause
void pause_menu(Res&lt;UserInput&gt; input, ResMut&lt;State&lt;GameState&gt;&gt; state) {
    DrawRectangle(0, 0, 800, 600, Fade(BLACK, 0.7f));
    DrawText("PAUSED", 300, 250, 60, WHITE);
    DrawText("ESC to resume", 300, 350, 30, GRAY);
}

int main() {
    Application{}
        .add_plugins(DefaultPlugins{})
        .insert_resource(State&lt;GameState&gt;{GameState::MainMenu})
        
        // Menu principal
        .add_systems&lt;main_menu_system&gt;(Schedule::UPDATE)
            .run_if&lt;in_state&lt;GameState::MainMenu&gt;&gt;()
        
        // Jeu
        .add_systems&lt;game_logic&gt;(Schedule::UPDATE)
            .run_if&lt;in_state&lt;GameState::Playing&gt;&gt;()
        
        // Pause
        .add_systems&lt;pause_handler&gt;(Schedule::UPDATE)
        .add_systems&lt;pause_menu&gt;(Schedule::RENDER_2D)
            .run_if&lt;in_state&lt;GameState::Paused&gt;&gt;()
        
        .run();
}</code></pre>
                </div>
            </div>
        </section>

        <!-- API Reference -->
        <section id="api-reference" class="section">
            <h1>Référence API Complète</h1>

            <div class="subsection">
                <h2>Scene</h2>
                <p>Container principal de l'ECS.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Méthode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Entity create_entity()</code></td>
                            <td>Crée une nouvelle entité vide</td>
                        </tr>
                        <tr>
                            <td><code>void destroy_entity(Entity e)</code></td>
                            <td>Détruit une entité et ses composants</td>
                        </tr>
                        <tr>
                            <td><code>void add_component&lt;T&gt;(Entity e, T comp)</code></td>
                            <td>Ajoute un composant à une entité</td>
                        </tr>
                        <tr>
                            <td><code>void remove_component&lt;T&gt;(Entity e)</code></td>
                            <td>Retire un composant d'une entité</td>
                        </tr>
                        <tr>
                            <td><code>T* get_component_ptr&lt;T&gt;(Entity e)</code></td>
                            <td>Obtient un pointeur vers un composant</td>
                        </tr>
                        <tr>
                            <td><code>bool has_component&lt;T&gt;(Entity e)</code></td>
                            <td>Vérifie si une entité a un composant</td>
                        </tr>
                        <tr>
                            <td><code>void insert_resource&lt;T&gt;(T&& r)</code></td>
                            <td>Insère une ressource globale</td>
                        </tr>
                        <tr>
                            <td><code>void remove_resource&lt;T&gt;()</code></td>
                            <td>Retire une ressource globale</td>
                        </tr>
                        <tr>
                            <td><code>T* get_resource_ptr&lt;T&gt;()</code></td>
                            <td>Obtient un pointeur vers une ressource</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>Commands</h2>
                <p>Interface pour modifications différées.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Méthode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>EntityCommands spawn()</code></td>
                            <td>Spawn une entité vide</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands spawn(Components...)</code></td>
                            <td>Spawn avec composants initiaux</td>
                        </tr>
                        <tr>
                            <td><code>void despawn(Entity e)</code></td>
                            <td>Planifie la destruction d'une entité</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands entity(Entity e)</code></td>
                            <td>Obtient un builder pour une entité existante</td>
                        </tr>
                        <tr>
                            <td><code>void insert_resource&lt;T&gt;(T res)</code></td>
                            <td>Planifie l'insertion d'une ressource</td>
                        </tr>
                        <tr>
                            <td><code>void remove_resource&lt;T&gt;()</code></td>
                            <td>Planifie le retrait d'une ressource</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>EntityCommands</h2>
                <p>Builder pour modification d'entités.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Méthode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>EntityCommands& insert&lt;T&gt;(T comp)</code></td>
                            <td>Ajoute un composant (chainable)</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands& remove&lt;T&gt;()</code></td>
                            <td>Retire un composant (chainable)</td>
                        </tr>
                        <tr>
                            <td><code>Entity id() const</code></td>
                            <td>Retourne l'ID de l'entité</td>
                        </tr>
                        <tr>
                            <td><code>EntityCommands& with_children(Func)</code></td>
                            <td>Ajoute des enfants à l'entité</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>Query&lt;Wrappers...&gt;</h2>
                <p>Itération sur les entités.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Méthode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Iterator begin() const</code></td>
                            <td>Début de l'itération</td>
                        </tr>
                        <tr>
                            <td><code>Iterator end() const</code></td>
                            <td>Fin de l'itération</td>
                        </tr>
                        <tr>
                            <td><code>u64 size() const</code></td>
                            <td>Nombre d'entités matchées</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Query::Iterator</h3>
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Méthode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Entity entity() const</code></td>
                            <td>Obtient l'ID de l'entité courante</td>
                        </tr>
                        <tr>
                            <td><code>auto operator*()</code></td>
                            <td>Obtient les wrappers de composants</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>EventWriter&lt;T&gt;</h2>
                <p>Envoi d'événements.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Méthode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>void send(const T& event)</code></td>
                            <td>Envoie un événement (copie)</td>
                        </tr>
                        <tr>
                            <td><code>void send(T&& event)</code></td>
                            <td>Envoie un événement (move)</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="subsection">
                <h2>EventReader&lt;T&gt;</h2>
                <p>Lecture d'événements.</p>
                
                <table class="api-table">
                    <thead>
                        <tr>
                            <th>Méthode</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>bool has_events() const</code></td>
                            <td>Vérifie s'il y a des événements</td>
                        </tr>
                        <tr>
                            <td><code>Iterator begin() const</code></td>
                            <td>Début de l'itération</td>
                        </tr>
                        <tr>
                            <td><code>Iterator end() const</code></td>
                            <td>Fin de l'itération</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <footer class="footer">
            <p>&copy; 2025 R-Engine Project. Documentation générée pour l'ECS.</p>
        </footer>
    </main>

    <script src="script.js"></script>
</body>
</html>